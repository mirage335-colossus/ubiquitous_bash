'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.promptUser = exports.getDependencies = undefined;

var getDependencies = exports.getDependencies = function () {
  var _ref = _asyncToGenerator(function* (packageName) {
    var toReturn = [];
    var packageModule = atom.packages.getLoadedPackage(packageName);
    var packageDependencies = packageModule && packageModule.metadata['package-deps'];

    if (packageDependencies) {
      var _arr = packageDependencies;

      for (var _i = 0; _i < _arr.length; _i++) {
        var entry = _arr[_i];
        var matches = DEPENDENCY_REGEX.exec(entry);
        if (matches === null) {
          console.error('[Package-Deps] Error parsing dependency of', packageName, 'with value:', entry);
          continue;
        }
        var parsed = {
          name: matches[1],
          url: matches[2] || matches[1],
          version: matches[3] || null
        };
        if (__steelbrain_package_deps.has(parsed.name)) continue;
        var resolvedPath = atom.packages.resolvePackagePath(parsed.name);
        if (resolvedPath) {
          if (!parsed.version) continue;
          var manifest = JSON.parse((yield _sbFs2.default.readFile(_path2.default.join(resolvedPath, 'package.json'))));
          // $FlowIgnore: Flow is paranoid, this parsed.version is NOT NULL
          if (_semver2.default.satisfies(manifest.version, '>=' + parsed.version)) continue;
        }
        __steelbrain_package_deps.add(parsed.name);
        toReturn.push(parsed);
      }
    } else {
      console.error('[Package-Deps] Unable to get loaded package \'' + packageName + '\'');
    }

    return toReturn;
  });

  return function getDependencies(_x) {
    return _ref.apply(this, arguments);
  };
}();

var promptUser = exports.promptUser = function () {
  var _ref2 = _asyncToGenerator(function* (packageName, dependencies) {
    var oldConfigPath = _path2.default.join(atom.getConfigDirPath(), 'package-deps-state.json');
    var ignoredPackages = atom.config.get('atom-package-deps.ignored') || [];

    if (yield _sbFs2.default.exists(oldConfigPath)) {
      var oldConfig = JSON.parse((yield _sbFs2.default.readFile(oldConfigPath, 'utf8')));
      atom.config.set('atom-package-deps.ignored', ignoredPackages = oldConfig.ignored);
      yield _sbFs2.default.unlink(oldConfigPath);
    }

    if (ignoredPackages.includes(packageName)) {
      return 'No';
    }

    if (atom.packages.isPackageDisabled('notifications')) {
      console.warn('Enable notifications to install dependencies for ' + packageName);
    }

    return new Promise(function (resolve) {
      var notification = atom.notifications.addInfo(packageName + ' needs to install dependencies', {
        dismissable: true,
        icon: 'cloud-download',
        detail: dependencies.map(function (e) {
          return e.name;
        }).join(', '),
        description: 'Install dependenc' + (dependencies.length === 1 ? 'y' : 'ies') + '?',
        buttons: [{
          text: 'Yes',
          onDidClick: function onDidClick() {
            resolve('Yes');
            notification.dismiss();
          }
        }, {
          text: 'No Thanks',
          onDidClick: function onDidClick() {
            resolve('No');
            notification.dismiss();
          }
        }, {
          text: 'Never',
          onDidClick: function onDidClick() {
            ignoredPackages.push(packageName);
            atom.config.set('atom-package-deps.ignored', ignoredPackages);
            if (!shownStorageInfo) {
              shownStorageInfo = true;
              atom.notifications.addInfo('How to reset package-deps memory', {
                dismissable: true,
                description: "To modify the list of ignored files invoke 'Application: Open Your Config' and change the 'atom-package-deps' section"
              });
            }
            resolve('Never');
            notification.dismiss();
          }
        }]
      });
      notification.onDidDismiss(function () {
        return resolve('No');
      });
    });
  });

  return function promptUser(_x2, _x3) {
    return _ref2.apply(this, arguments);
  };
}();

exports.apmInstall = apmInstall;

var _sbFs = require('sb-fs');

var _sbFs2 = _interopRequireDefault(_sbFs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _atom = require('atom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var shownStorageInfo = false;
var VALID_TICKS = new Set(['âœ“', 'done']);
var VALIDATION_REGEXP = /(?:Installing|Moving) (.*?) to .* (.*)/;

function exec(command, parameters) {
  return new Promise(function (resolve) {
    var data = { stdout: [], stderr: [] };
    var spawnedProcess = new _atom.BufferedProcess({
      command: command,
      args: parameters,
      stdout: function stdout(chunk) {
        data.stdout.push(chunk);
      },
      stderr: function stderr(chunk) {
        data.stderr.push(chunk);
      },
      exit: function exit() {
        resolve({ stdout: data.stdout.join(''), stderr: data.stderr.join('') });
      },

      autoStart: false
    });
    spawnedProcess.start();
  });
}

function apmInstall(dependencies, progressCallback) {
  var errors = new Map();
  return Promise.all(dependencies.map(function (dep) {
    return exec(atom.packages.getApmPath(), ['install', dep.version ? dep.url + '@' + dep.version : dep.url, '--production', '--color', 'false']).then(function (output) {
      var successful = VALIDATION_REGEXP.test(output.stdout) && VALID_TICKS.has(VALIDATION_REGEXP.exec(output.stdout)[2]);
      progressCallback(dep.name, successful);
      if (!successful) {
        var error = new Error('Error installing dependency: ' + dep.name);
        error.stack = output.stderr;
        throw error;
      }
    }).catch(function (error) {
      errors.set(dep.name, error);
    });
  })).then(function () {
    return errors;
  });
}

var DEPENDENCY_REGEX = /^([^#:]+)(?:#([^:]+))?(?::(.+))?$/;