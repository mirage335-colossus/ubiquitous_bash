"use strict";


/**
 * Encode a UTF-8 string using MIME base64.
 *
 * @example base64Encode("cáfé") == "Y8OhZsOp"
 * @param {String} data
 * @return {String}
 */
function base64Encode(data){

	// Convert UTF-8 strings to whatever "normal" encoding is needed to safely manipulate data at binary-level.
	data = ((data => {
		let output = "";
		const char = String.fromCharCode;
		const {length} = data;
		for(let i = 0; i < length; ++i){
			const c = data.charCodeAt(i);
			if(c < 128)                      output += char(c);
			else if((c > 127) && (c < 2048)) output += char((c >> 6)  | 192) + char((c & 63)        | 128);
			else                             output += char((c >> 12) | 224) + char(((c >> 6) & 63) | 128) + char((c & 63) | 128);
		}
		return output;
	})(data.replace(/\r\n/g, "\n")));
	
	// Apply base64 encoding
	const codex = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	let encoded = ""
	for(let i = 5, n = data.length * 8 + 5; i < n; i += 6)
		encoded += codex[(data.charCodeAt(~~(i/8)-1) << 8 | data.charCodeAt(~~(i/8))) >> 7 - i%8 & 63];
	for(; encoded.length % 4; encoded += "=");
	return encoded;
}


/**
 * Decode a base64-encoded string as UTF-8.
 *
 * @example base64Decode("Y8OhZsOp") == "cáfé"
 * @param {String} data
 * @return {String}
 */
function base64Decode(data){
	const codex = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	const char = String.fromCharCode;
	let output = "";
	let i = 0;
	data = data.replace(/[^A-Za-z0-9\+\/=]/g, "");
	
	const {length} = data;
	while(i < length){
		const a = codex.indexOf(data[i++]);
		const b = codex.indexOf(data[i++]);
		const c = codex.indexOf(data[i++]);
		const d = codex.indexOf(data[i++]);
		output += char((a << 2) | (b >> 4));
		if(64 !== c) output += char(((b & 15) << 4) | (c >> 2));
		if(64 !== d) output += char(((c &  3) << 6) | d);
	}
	
	// Re-encode data as UTF-8
	return ((data => {
		const {length} = data;
		let output = "";
		let i = 0;
		while(i < length){
			const c = data.charCodeAt(i);
			if(c < 128){                      output += char(c); ++i; }
			else if((c > 191) && (c < 224)){  output += char(((c & 31) <<  6) |  (data.charCodeAt(i+1) & 63)); i += 2; }
			else{                             output += char(((c & 15) << 12) | ((data.charCodeAt(i+1) & 63) << 6) | (data.charCodeAt(i+2) & 63)); i += 3; }
		}
		return output;
	})(output));
}


/**
 * Generate a base64-encoded 4x4-size PNG image of a designated RGBA value.
 *
 * @param {Number} r - Red component (0-255)
 * @param {Number} g - Green component (0-255)
 * @param {Number} b - Blue component (0-255)
 * @param {Number} a - Alpha value (0-255: transparent to opaque)
 * @param {Boolean} [raw=false] - Return raw, unencoded bytestream.
 *
 * @return {String} Base64-encoded PNG data
 * @example rgba(255, 0, 0, 255) == "iVBORw0KGgoAAAANSU…ErkJggg=="
 */
function rgba(r, g, b, a, raw = false){
	const char = String.fromCharCode;
	const hton = i => String.fromCharCode(i >>> 24, i >>> 16 & 255, i >>> 8 & 255, i & 255);
	
	// PNG header
	const IHDR = "\x89PNG\r\n\x1A\n\0\0\0\rIHDR\0\0\0\x04\0\0\0\x04\x08\x06\0\0\0\xA9\xF1\x9E~\0\0\0O";
	
	// IDAT (Image Data) chunk
	const IDAT = "IDAT\x08\x1D\x01D\0\xBB\xFF";
	const data = "\x01" + char(r) + char(g) + char(b) + char(a) + "\0".repeat(12)
		+ "\x02" + `${"\0".repeat(16)}\x02`.repeat(2)
		+ "\0".repeat(16);
	
	const crc1 = hton((data => {
		// Addler's algorithm
		let a = 1, b = 0;
		const l = data.length;
		const k = 65521;
		for(let i = 0; i < l; ++i){
			a = (a + data.charCodeAt(i)) % k;
			b = (b + a) % k;
		}
		return b << 16 | a;
	})(data));
	
	const crc2 = hton((data => {
		// CRC32
		let c = ~0;
		const l = data.length;
		for(let i = 0; i < l; ++i)
			for(let b = data.charCodeAt(i) | 0x100; b != 1; b >>>= 1)
				c = (c >>> 1) ^ ((c ^ b) & 1 ? 0xEDB88320 : 0);
		return ~c;
	})(IDAT + data + crc1));

	// Concatenate image-data and close PNG stream with IEND chunk.
	const bytes = IHDR + IDAT + data + crc1 + crc2 + "\0".repeat(4) + "IEND\xAEB`\x82";
	
	return raw ? bytes : ((data => {
		// Base64-encode that bitch
		const codex = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		let encoded = "";
		for(let i = 5, n = data.length * 8 + 5; i < n; i += 6)
			encoded += codex[(data.charCodeAt(~~(i/8)-1) << 8 | data.charCodeAt(~~(i/8))) >> 7 - i%8 & 63];
		for(; encoded.length % 4; encoded += "=");
		return encoded;
	})(bytes));
}


/**
 * Encode a sequence of single-byte characters as UTF-8.
 *
 * @example UTF8Encode("cÃ¡fÃ©bÃ¡bÃ©") == "cáfébábé"
 * @param {String} data
 * @return {String}
 */
function UTF8Encode(data){
	const {length} = data;
	let s = "";
	let i = 0;
	while(i < length){
		const c = data.charCodeAt(i);
		if(c < 128)                     { s += String.fromCharCode(c); ++i; }
		else if((c > 191) && (c < 224)) { s += String.fromCharCode(((c & 31) << 6)  |  (data.charCodeAt(i+1) & 63)); i += 2; }
		else                            { s += String.fromCharCode(((c & 15) << 12) | ((data.charCodeAt(i+1) & 63) << 6) | (data.charCodeAt(i+2) & 63)); i += 3; }
	}
	return s;
}


/**
 * Break a UTF-8 string into a stream of single-byte sequences.
 *
 * @example UTF8Decode("cáfébábé") == "cÃ¡fÃ©bÃ¡bÃ©"
 * @param {String} data
 * @return {String}
 */
function UTF8Decode(data){
	data = data.replace(/\r(?=\n)/g, "");
	const {length} = data;
	let output = "";
	for(let i = 0; i < length; ++i){
		const c = data.charCodeAt(i);
		if(c < 128)                      output += String.fromCharCode(c);
		else if((c > 127) && (c < 2048)) output += String.fromCharCode((c >> 6)  | 192) + String.fromCharCode((c & 63)        | 128);
		else                             output += String.fromCharCode((c >> 12) | 224) + String.fromCharCode(((c >> 6) & 63) | 128) + String.fromCharCode((c & 63) | 128);
	}
	return output;
}


/**
 * Draw a polygon from a sequence of points.
 *
 * @param {CanvasRenderingContext2D} context
 * @param {Number[]} points
 */
function drawPolygon(context, points){
	context.beginPath();
	for(const point of points){
		const [x, y] = point;
		context.lineTo(x, y);
	};
	context.closePath();
	context.stroke();
}


/**
 * Return the context's current font-style as separate properties.
 *
 * @param {CanvasRenderingContext2D} context
 * @return {Object} Hash of font-related CSS properties.
 */
function getCanvasFont(context){
	const el = document.createElement("div");
	el.style.cssText = "font: " + context.font + " !important;";
	
	context.canvas.appendChild(el);
	const style = window.getComputedStyle(el);
	const output = {
		fontFamily:   style.fontFamily,
		fontSize:     style.fontSize,
		fontStyle:    style.fontStyle,
		fontVariant:  style.fontVariant,
		fontWeight:   style.fontWeight,
		lineHeight:   style.lineHeight
	};
	context.canvas.removeChild(el);
	return output;
}


/**
 * Draw a soft-wrapping, rectangular region of text.
 *
 * @uses {@link getCanvasFont}
 * @param {CanvasRenderingContext2D} context
 * @param {String|Array} text - Text content, expressed as either a string or an array of substrings representing each word.
 * @param {Number} [x=0] - X coordinate of textarea.
 * @param {Number} [y=0] - Y coordinate of textarea.
 * @param {Number} [w=(context.canvas.width - x * 2)] - Textarea's width
 * @param {Number} [h=(context.canvas.height - y * 2)] - Textarea's height
 * @param {Number} [leading=1] - Multiplier to adjust overall line-height.
 * @param {Number} [indent=0] - Leading indentation applied to first line.
 *
 * @return {Object} A hash keyed with the following properties:
 *  - x: X coordinate that the context finished drawing text at (relative to canvas object).
 *  - y: Y coordinate the context finished drawing text at
 *  - remainder: Remaining text that couldn't fit inside the textarea.
 */
function drawTextArea(context, text, x=0, y=0, w=0, h=0, leading=1, indent=0){
	const words = Array.isArray(text) ? text : text.split(/\b(?=\S)|(?=\s)/g);
	const font = getCanvasFont(context);
	const size = parseInt(font.fontSize);
	const {textBaseline} = context;
	context.textBaseline = "top";
	
	let rowLength = indent;
	let totalHeight = 0;
	leading *= size;
	w = w || context.canvas.width - x * 2;
	h = h || context.canvas.height - y * 2;
	
	for(let i = 0; i < words.length; ++i){
		let diff, width;

		// Newline: Don't measure, just increase total height
		if("\n" === words[i]){
			rowLength = 0;
			totalHeight += leading;
			
			// Terminate if newline pushed remaining text outside drawing area
			if(totalHeight + leading >= h) return {
				x: rowLength + x,
				y: totalHeight + y,
				remainder: words.slice(i)
			};
			continue;
		}

		// Strip leading tabs
		if(!rowLength && /^\t+/.test(words[i]))
			words[i] = words[i].replace(/^\t+/, "");
		
		// This is one honkin' long word, so try to hyphenate it
		let s, measuredWidth = context.measureText(words[i]).width;
		if(0 >= (diff = w - measuredWidth)){
			diff = Math.abs(diff);
			
			// Decide which end to measure from.
			if(diff - w <= 0)
				for(s = words[i].length; s; --s){
					const string = words[i].substr(0, s) + "-";
					if(w > context.measureText(string.width + size)){
						breakPoint = s;
						break;
					}
				}
			else{
				const {length} = words[i];
				for(let s = 0; s < length; ++s){
					const string = words[i].substr(0, s + 1) + "-";
					if(w < context.measureText(string.width + size)){
						breakPoint = s;
						break;
					}
				}
			}
			if(breakPoint){
				const left  = words[i].substr(0, s+1) + "-";
				const right = words[i].substr(s+1);
				words[i] = left;
				words.splice(i+1, 0, right);
				measuredWidth = context.measureText(left).width;
			}
		}
		
		// No room on current line to fit next word: start another line.
		if(rowLength > 0 && rowLength + measuredWidth >= w){
			
			// We've run out of vertical room too. Return any remaining words that couldn't fit.
			if(totalHeight + leading * 2 >= h) return {
				x: rowLength   + x,
				y: totalHeight + y,
				remainder: words.slice(i)
			};
			rowLength = 0;
			totalHeight += leading;

			// If current word is just a space, skip it to avoid adding a weird-looking gap.
			if(" " === words[i]) continue;
		}

		// Write another word and increase total line-length.
		context.fillText(words[i], rowLength+x, totalHeight+y);
		rowLength += measuredWidth;
	}

	// Restore original context.textBaseline
	context.textBaseline = textBaseline;
	return {x: rowLength + x, y: totalHeight + y, remainder: []};
}



/**
 * Draw a DOM element to the canvas.
 *
 * Not supported on IE9.
 *
 * @param {CanvasRenderingContext2D} context
 * @param {Node} node
 * @param {Number} [x=0]
 * @param {Number} [y=0]
 * @param {Number} [w=context.canvas.width]
 * @param {Number} [h=context.canvas.height]
 * @return {Image}
 */
function drawHTML(context, node, x=0, y=0, w=0, h=0){
	w = w || context.canvas.width;
	h = h || context.canvas.height;
	
	// Snapshot rendered appearance of each contained element
	const nodeAppearances = [];
	for(const child of node.querySelectorAll("*")){
		const style = window.getComputedStyle(child);
		nodeAppearances.push(style.cssText || (function(){
			let cssText = "";
			for(const name of style){
				const value = style[name];
				if(value) cssText += `${name}: ${value}; `;
			}
			return cssText;
		}()));
	}
	
	// Assumption: descendants of cloned node are returned in the same order as before
	const carbonCopy = node.cloneNode(true);
	Array.from(carbonCopy.querySelectorAll("*")).forEach((child, i) =>
		child.setAttribute("style", nodeAppearances[i]));
	
	// Parse node's HTML content as well-formed XHTML: needed to pass through SVG
	const doc = document.implementation.createHTMLDocument("");
	doc.documentElement.setAttribute("xmlns", doc.documentElement.namespaceURI);
	doc.body.innerHTML = carbonCopy.outerHTML;
	const markup = (new XMLSerializer).serializeToString(doc).replace(/<!DOCTYPE[^>]*>/i, "");
	const svgSrc = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}px" height="${h}px">` +
		`<foreignObject width="100%" height="100%">` +
			`<div xmlns="http://www.w3.org/1999/xhtml">${markup}</div>` +
		"</foreignObject></svg>";
	
	// Generate image
	const img = new Image();
	img.onload = () => context.drawImage(img, x, y, w, h);
	img.src = "data:image/svg+xml;utf8," + encodeURIComponent(svgSrc);
	return img;
}


/**
 * Curried method to append multiple nodes at once.
 *
 * @example addTo(node)(el1, el2, …)
 * @example node = addTo(node)(…)[0]
 * @return {Function}
 */
function addTo(parent){
	let count = 0;
	let target = parent;
	
	const fn = (...nodes) => {
		let lastElement;
		
		for(let node of nodes){
			if("string" === typeof node)
				node = document.createTextNode(node);
			else if(node)
				lastElement =
				fn[++count] = node;
			node && target.appendChild(node);
		}
		
		target = lastElement || target;
		return fn;
	};
	fn[count] = target;
	return fn;
}


/**
 * Build a dictionary object from the contents of a <dl> element.
 *
 * If more than one <dd> tag falls under a single definition, the term is
 * assigned an array of strings instead. If duplicate definitions are encountered,
 * their values are appended to the array of the previously-defined definition.
 *
 * @param {HTMLDListElement} dl
 *    Description list from which to construct a hash of named values.
 *
 * @param {Boolean} [valueKey="textContent"]
 *    Name of property from which to derive definitions from.
 *
 * @param {Function|RegExp} [filter=/^\s*|\s*:\s*$/g]
 *    Callback or regex to execute on each definition's name.
 *    If a RegExp is supplied, it's used to delete matching characters from
 *    the name instead (defaulting to a regex which strips trailing colons).
 *
 * @return {Object}
 */
function buildDict(dl, valueKey = "textContent", filter = /^\s*|\s*:\s*$/g){
	const output = {};
	
	if("function" !== typeof filter){
		const pattern = filter;
		filter = s => s.replace(pattern, "");
	}
	
	let key, value;
	for(const node of dl.childNodes)
		switch(node.tagName){
			case "DT":
				key = filter(node[valueKey]);
				break;
			
			case "DD":
				const existingValue = output[key];
				if(existingValue != null && !Array.isArray(existingValue))
					output[key] = [existingValue];
				
				value = node[valueKey];
				undefined === output[key]
					? output[key] = value
					: output[key].push(value);
				break;
		}
	return output;
}


/**
 * Retrieve every text-node contained by a DOM element.
 *
 * @param {Element} el
 *    Element to recursively scan for text-nodes.
 *
 * @param {String} [filter]
 *    CSS selector to skip nodes of unwanted elements.
 *
 * @example collectTextNodes(el, "#ignore > .this");
 * @return {CharacterData[]}
 */
function collectTextNodes(el, filter = ""){
	const nodes = [];
	for(const node of el.childNodes)
		switch(node.nodeType){
			case Node.TEXT_NODE:
				nodes.push(node);
				break;
			case Node.ELEMENT_NODE:
				if(!filter || !node.matches(filter))
					nodes.push(...collectTextNodes(node));
		}
	return nodes;
}


/**
 * Get or set a cookie's value.
 *
 * If neither name or value are passed, the function returns all
 * available cookies enumerated as a single object-hash.
 *
 * @param {String}  name - Cookie's name
 * @param {String}  [value] - Value to assign. Passing `null` deletes the cookie.
 * @param {Object}  [attr={}] - Cookie attributes used when invoked as a setter.
 * @param {String}  [attr.expires=""] - GMT-formatted expiration date
 * @param {String}  [attr.path=""] - Absolute path of cookie
 * @param {String}  [attr.domain=""] - Domains/subdomains
 * @param {Boolean} [attr.secure=false] - Specify cookie must be sent over HTTPS.
 * @return {String} If invoked as a getter, returns cookie's existing value.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie}
 */
function cookie(name, value, options = {}){
	
	// If no name was specified, return all available cookies.
	if(!name){
		const output = {};
		for(const cookie of document.cookie.split(/;\s*/)){
			const split = cookie.indexOf("=");
			if(cookie && split > 0){
				const name   = cookie.substr(0, split);
				const value  = cookie.substr(split + 1);
				output[name] = decodeURIComponent(value);
			}
		}
		return output;
	}
	
	// Getter
	if(undefined === value){
		const split = name.length + 1;
		for(const cookie of document.cookie.split(/;\s*/))
			if(name + "=" === cookie.substr(0, split))
				return decodeURIComponent(cookie.substr(split));
		return null;
	}
	
	// Setter
	else{
		let {expires} = options;
		if(null === value){
			expires = -1;
			value   = "";
		}
		if(expires){
			const dateObj = !(expires instanceof Date)
				? new Date(Date.now() + (86400000 * expires))
				: expires;
			expires = dateObj.toUTCString();
		}
		document.cookie = name + "=" + encodeURIComponent(value)
			+ (expires        ? "; expires="+ expires        : "") 
			+ (options.path   ? "; path="   + options.path   : "")
			+ (options.domain ? "; domain=" + options.domain : "")
			+ (options.secure ? "; secure"  : "");
	}
}


/**
 * Return the deepest-nested descendant of an element.
 *
 * @param {Element} el
 * @return {Node}
 */
function deepest(el){
	if(!el.childElementCount) return el;
	const branches = [];
	for(const child of el.querySelectorAll("*")){
		let depth = 0;
		let parent = child.parentNode;
		while(parent !== el){
			++depth;
			parent = parent.parentNode;
		}
		branches.push([depth, child]);
	}
	let max = [-1, null];
	for(const child of branches)
		if(child[0] > max[0]) max = child;
	return max[1];
}


/**
 * Export a table's data as a list of objects.
 *
 * @param {HTMLTableElement} table
 * @return {Object[]}
 */
function extractTableData(table){
	const headers = [];
	const data = [];
	
	// Column names
	const tHeads = table.tHead
		? table.tHead.querySelectorAll("tr:first-child > th")
		: table.tBodies[0].querySelectorAll("tr:first-child > td");
	for(const th of tHeads)
		headers.push(th.textContent.trim());
	
	// Table data
	for(const tBody of table.tBodies)
		for(const tr of tBody.rows){
			let columnIndex = 0;
			const row = {};
			for(const cell of tr.cells){
				const columnName = headers[columnIndex++];
				row[columnName] = cell.textContent.trim();
			}
			data.push(row);
		}
	return data;
}


/**
 * Measure the scrollbar-width of the current OS/device.
 *
 * @example
 * getScrollbarWidth() == 12 // Windows 10
 * getScrollbarWidth() == 0  // macOS
 * @return {Number}
 */
function getScrollbarWidth(){
	const doc = document.body || document.documentElement;
	const tmp = document.createElement("div");
	const {style} = tmp;
	const size    = 120;
	style.cssText = `width: ${size}px; height: ${size}px; overflow: auto;`;
	tmp.innerHTML = " W ".repeat(size * 5);
	
	doc.appendChild(tmp);
	const width = tmp.offsetWidth - tmp.scrollWidth;
	doc.removeChild(tmp);
	return width;
}


/**
 * Resolve the name of the supported WebGL rendering context.
 *
 * If no WebGL is unsupported, an empty string is returned.
 *
 * @example getWebGLSupport() == "webgl"     // Chrome 57
 * @example getWebGLSupport() == "moz-webgl" // Old FireFox
 * @return {String}
 */
function getWebGLSupport(){
	const canvas = document.createElement("canvas");
	const names = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"];
	for(const name of names)
		try{ if(canvas.getContext(name)) return name; }
		catch(e){ }
	return "";
}


/**
 * Inject <wbr /> elements into lengthy words in an element.
 *
 * @uses {@link collectTextNodes}
 * @param {Element} element
 *    DOM element to operate upon.
 * @param {Number} [limit=80]
 *    Number of characters to traverse in a single word before inserting a breakpoint.
 * @return {HTMLElement} An array of <wbr /> elements that were inserted.
 */
function injectWordBreaks(element, limit = 80){
	const terminators = '.,+*?$|#{}()\\^\\-\\[\\]\\\\\/!%\'"~=<>_:;\\s';
	const regexSource = "([^" + terminators + "]{" + limit + "})";
	
	const injections = [];
	for(const node of collectTextNodes(element)){
		const splitBy = new RegExp(regexSource, "g");
		const breakPoints = [];
		
		// Collect a list of insertion points.
		while(splitBy.exec(node.data))
			breakPoints.push(splitBy.lastIndex);
		
		for(const breakPoint of breakPoints.reverse()){
			const wbr = document.createElement("wbr");
			const otherHalf = node.splitText(breakPoint);
			node.parentNode.insertBefore(wbr, otherHalf);
			injections.push(wbr);
		}
	}
	return injections;
}


/**
 * Retrieve a node's first ancestor which matches a CSS selector.
 *
 * @param {Node} subject - DOM node to query the ancestry of
 * @param {String} selector - A CSS selector string
 * @param {Boolean} [ignoreSelf=false] - Exempt subject from matching selector
 * @return {Element} The closest matching container, or `null` if nothing in the searched ancestry matched the selector.
 */
function nearest(subject, selector, ignoreSelf = false){
	subject = ignoreSelf ? subject.parentNode : subject;
	if("function" === typeof Element.prototype.matches)
		while(subject){
			if(subject.matches(selector)) return subject;
			subject = subject.parentNode;
		}
	else{ // Dumbed-down version for IE8
		const matches = document.querySelectorAll(selector);
		if(matches.length) while(subject){
			for(const match of matches)
				if(match === subject) return subject;
			subject = subject.parentNode;
		}
	}
	return null;
}


/**
 * Check if the browser is a particular version of Internet Explorer.
 *
 * @example isIE(8, ">") == // IE9+
 * @param {String} version - Version to check against.
 * @param {String} operand - String describing the type of comparison to perform.
 * @return {Boolean}
 */
function isIE(version, operator){
	switch(operator){
		case "<":  operator = "lt ";  break;
		case "<=": operator = "lte "; break;
		case ">":  operator = "gt ";  break;
		case ">=": operator = "gte "; break;
		case "!=": operator = "!";    break;
		default:   operator = "";     break;
	}
	const div = document.createElement("div");
	div.innerHTML = "<!--[if " + operator + "IE " + version + "]><i></i><![endif]-->";
	return !!div.getElementsByTagName("i").length;
}


/**
 * Create a new DOM element.
 *
 * @example New("div", {
 *   className: "foo",
 *   textContent: "bar"
 * }) == HTML`<div class="foo">bar</div>`
 * 
 * @param {String} type - Tag-name of element to create.
 * @param {Object} [attr] - Optional attributes to assign.
 * @return {Element}
 */
function New(type, attr = null){
	function absorb(a, b){
		for(const i in b)
			if(Object(a[i]) === a[i] && Object(b[i]) === b[i])
				absorb(a[i], b[i]);
			else a[i] = b[i];
	};
	const node = document.createElement(type);
	if(null !== attr) absorb(node, attr);
	return node;
}


/**
 * Convert a CSS {@link https://developer.mozilla.org/en-US/docs/Web/CSS/time|`time`} to milliseconds.
 *
 * @example parseCSSDuration("4s") == 4000
 * @param {String} value - A CSS time value
 * @return {Number}
 */
function parseCSSDuration(time){
	if("string" !== typeof time) return value;
	return /\ds\s*$/.test(time)
		? parseFloat(time) * 1000
		: parseFloat(time);
}


/**
 * Extract DOM elements from a chunk of HTML source.
 * 
 * @param {String} input
 * @return {Node[]}
 */
function parseHTMLFragment(input){
	const fragment = document.createDocumentFragment();
	const output = [];
	let tagType = (input.match(/^[^<]*<([-\w]+)/) || [,""])[1];
	switch(tagType.toLowerCase()){
		case "thead":
		case "tbody":
		case "tfoot":
		case "caption":
			input = "<table>" + input + "</table>";
			break;
		case "tr":
			input = "<table><tbody>" + input + "</tbody></table>";
			break;
		case "th":
		case "td":
			input = "<table><tbody><tr>" + input + "</tr></tbody></table>";
			break;
		default:
			tagType = "";
	}
	let root = fragment.appendChild(document.createElement("div"));
	root.insertAdjacentHTML("afterbegin", input);
	if(tagType && (tagType = root.querySelector(tagType)))
		root = tagType.parentNode;
	while(root.firstChild)
		output.push(root.removeChild(root.firstChild));
	return output;
}


/**
 * Check if the browser supports a CSS property.
 *
 * @example supportsCSSProperty("Transform") == false in IE8
 * @param {String} n - CSS property name, supplied in sentence case (e.g., "Transition")
 * @return {Boolean} Whether the browser supports the property (either prefixed or unprefixed).
 */
function supportsCSSProperty(name){
	const {style} = document.documentElement;
	if(name.toLowerCase() in style) return true;
	const prefixes = [
		"Webkit", "Moz", "Ms", "O", "Khtml",
		"webkit", "moz", "ms", "o", "khtml"
	];
	for(const prefix of prefixes)
		if(prefix + name in style) return true;
	return false;
}


/**
 * Check if the browser understands a CSS selector.
 *
 * Not supported in IE6-7, which always report `true` (even for unsupported selectors).
 *
 * @example supportsCSSSelector("input:checked")
 * @param {String} selector
 * @return {Boolean}
 */
function supportsCSSSelector(selector){
	const ruleset = selector + "{}";
	const styleEl = document.body.appendChild(document.createElement("style"));
	let {sheet} = styleEl;
	
	if(sheet){
		styleEl.textContent = ruleset;
		sheet = styleEl.sheet;
	}
	else{
		sheet = styleEl.styleSheet;
		sheet.cssText = ruleset;
	}
	
	const {length} = sheet.cssRules || sheet.rules;
	document.body.removeChild(styleEl);
	return 0 !== length;
}


/**
 * Check if the browser appears to support a CSS unit.
 *
 * @example supportsCSSUnit("rem")
 * @param {String} name - Unit's name
 * @return {Boolean}
 */
function supportsCSSUnit(name){
	try{
		const d = document.createElement("div");
		d.style.width = "32" + name;
		return d.style.width == "32" + name;
	} catch(e){return false;}
}


/**
 * Bind each of an object's methods to itself.
 *
 * @param {Object} subject
 * @return {Object} The object that was passed.
 */
function bindMethods(subject){
	const proto = subject.constructor.prototype;
	const keys = new Set([
		...Object.getOwnPropertyNames(proto),
		...Object.keys(subject)
	]);
	for(const key of keys)
		if("function" === typeof subject[key] && "constructor" !== key)
			subject[key] = subject[key].bind(subject);
	return subject;
}


/**
 * Synchronous, callback-aware version of Promise.all.
 *
 * Functions are resolved using their return values.
 * All other values are resolved normally.
 *
 * An array of values may also be used instead of multiple
 * arguments. The array must be the only argument given.
 *
 * @example chain(() => promise1, "string"…);
 * @param {...*} values
 * @return {Promise}
 */
function chain(...values){
	if(1 === values.length && Array.isArray(values[0]))
		values = [...values[0]];
	
	let promise = Promise.resolve();
	let rejection = null;
	const results = [];
	
	for(const value of values)
		promise = promise.then(result => {
			results.push(result);
			return "function" === typeof value ? value() : value;
		}).catch(error => {
			if(null === rejection)
				rejection = null == error ? true : error;
			return Promise.reject(error);
		});
	
	return promise.then(result => {
		results.push(result);
		results.shift();
		return null !== rejection
			? Promise.reject(rejection)
			: Promise.resolve(results);
	});
}


/**
 * Stop a function from firing too quickly.
 *
 * Returns a copy of the original function that runs only after the designated
 * number of milliseconds have elapsed. Useful for throttling onResize handlers.
 *
 * @param {Function} fn - Function to debounce
 * @param {Number} [limit=0] - Threshold to stall execution by, in milliseconds.
 * @param {Boolean} [asap=false] - Call function *before* threshold elapses, not after.
 * @return {Function}
 */
function debounce(fn, limit = 0, asap = false){
	let started, context, args, timing;
	
	const delayed = function(){
		const timeSince = Date.now() - started;
		if(timeSince >= limit){
			if(!asap) fn.apply(context, args);
			if(timing) clearTimeout(timing);
			timing = context = args = null;
		}
		else timing = setTimeout(delayed, limit - timeSince);
	};
	
	// Debounced copy of original function
	return function(){
		context = this,
		args    = arguments;
		if(!limit)
			return fn.apply(context, args);
		started = Date.now();
		if(!timing){
			if(asap) fn.apply(context, args);
			timing = setTimeout(delayed, limit);
		}
	};
}


/**
 * Generate an exception-proof version of a function.
 *
 * @param {Function} fn
 * @param {Object} [context]
 * @return {Function}
 */
function nerf(fn, context = null){
	if("function" !== typeof fn)
		throw new TypeError("Argument must be a function");
	
	let lastError = null;
	const handler = function(...args){
		let result = null;
		try{result = fn.call(context, ...args)}
		catch(e){lastError = e}
		finally{return result}
	};
	return Object.defineProperty(handler, "lastError", {
		get(){ return lastError; },
		set(e){ lastError = e; }
	});
}


/**
 * Monkey-patch an object's method with another function.
 *
 * @param {Object} subject
 * @param {String} methodName
 * @param {Function} handler
 * @return {Function[]}
 */
function punch(subject, methodName, handler){
	const value = subject[methodName];
	const originalMethod = "function" !== typeof value
		? () => value
		: value;
	
	const punchedMethod = function(){
		const call = () => originalMethod.apply(this, arguments);
		const args = Array.from(arguments);
		return handler.call(this, call, args);
	};
	
	subject[methodName] = punchedMethod;
	return [originalMethod, punchedMethod];
}


/**
 * Return a {@link Promise} which auto-resolves after a delay.
 *
 * @param {Number} [delay=100] - Delay in milliseconds
 * @return {Promise}
 */
function wait(delay = 100){
	return new Promise(resolve => {
		setTimeout(() => resolve(), delay);
	});
}


/**
 * Generate a random integer within a range.
 *
 * @example random(2, 50) == 23
 * @param {Number} max
 * @param {Number} [min=0]
 * @return {Number}
 */
function random(max, min = 0){
	return Math.floor(Math.random() * max - min + 1) + min;
}


/**
 * Measure the arctangent between two points.
 *
 * An "arctangent" is the angle required for one point to face another.
 *
 * @example angleTo([0, 0], [60, 90]) == 123.69
 * @typedef {Number[]} Point
 * @param {Point} a
 * @param {Point} b
 * @return {Number}
 */
function angleTo(a, b){
	return (Math.atan2(b[1] - a[1], a[0] - b[0])) * 180 / Math.PI;
}


/**
 * Measure the distance between two points.
 *
 * @example distance([30, 0], [0, 40]) == 50
 * @param {Point} a
 * @param {Point} b
 * @return {Number}
 */
function distance(a, b){
	return Math.sqrt(Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2));
}


/**
 * Convert radians to degrees.
 *
 * @example radToDeg(Math.PI) == 180
 * @param {Number} value
 * @return {Number}
 */
function radToDeg(value){
	return value * 180 / Math.PI;
}


/**
 * Convert degrees to radians.
 *
 * @example degToRad(180) == Math.PI
 * @param {Number} value
 * @return {Number}
 */
function degToRad(value){
	return value * Math.PI / 180;
}


/**
 * Apply De Casteljau's algorithm to an array of points to ascertain the final midpoint.
 *
 * This formula is the basis of drawing [Bézier curves]{@link http://www.malinc.se/m/DeCasteljauAndBezier.php}.
 *
 * @param {Point[]} points - An array of points, each expressed as an array of two numbers
 * @param {Number} [position=0.5] - A multiplier indicating the current distance along the curve.
 * @return {Point[]} An array of 3 points: in-tangent, midpoint, and out-tangent.
 *
 * @example
 * <caption>
 *    Retrieve the midpoint of a roughly 100×50-sized semicircle: <br/>
 *    <svg width="101" height="50"><title>◠</title><path fill="none" stroke="#000" d="M 0,50 C 0 -15, 100 -15, 100, 50"/></svg>
 * </caption>
 * deCasteljau([
 *    [0,    50], // Left vertex
 *    [0,   -15], // Left vertex's out-tangent ("handle")
 *    [100, -15], // Right vertex's in-tangent
 *    [100,  50], // Right vertex
 * ]) == [
 *    [50, 1.25], // Midpoint's in-tangent
 *    [25, 1.25], // Midpoint
 *    [75, 1.25], // Midpoint's out-tangent
 * ];
 */
function deCasteljau(points, position = 0.5){
	let a, b, midpoints = [];
	
	while(points.length > 1){
		const num = points.length - 1;
		for(let i = 0; i < num; ++i){
			a = points[i];
			b = points[i+1];
			midpoints.push([
				a[0] + ((b[0] - a[0]) * position),
				a[1] + ((b[1] - a[1]) * position)
			]);
		}
		points = midpoints;
		midpoints = [];
	}

	return [points[0], a, b];
}


/**
 * Clamp a value to ensure it falls between a designated range.
 *
 * @example clamp(100, 32) == 32
 * @param {Number} input - Value to operate upon
 * @param {Number} min - Lower threshold; defaults to 0
 * @param {Number} max - Upper threshold; defaults to 1
 * @return {Number}
 */
function clamp(input, min = 0, max = 1){
	return Math.min(Math.max(input, min), max);
}

const fs = require("fs");
const {resolve} = require("path");


/**
 * Asynchronously load a resource.
 *
 * @param {String} url - URL or filesystem path
 * @param {String} [encoding="utf8"]
 * @return {Promise}
 * @public
 */
function load(url, encoding = "utf8"){
	return new Promise((resolve, reject) => {
		const protocol = url.match(/^https?/);
		
		// Remote resource: HTTPS or HTTP
		if(protocol){
			let result = "";
			const {get} = require(protocol[0].toLowerCase());
			const request = get(url, response => {
				if(response.statusMessage !== "OK")
					return reject(response);
				encoding && response.setEncoding(encoding);
				response.on("data", s => result += s);
				response.on("end", () => resolve(result));
			});
			request.on("error", e => reject(e));
		}
		
		// Assume parameter to be a filesystem path
		else{
			const fs = require("fs");
			fs.readFile(url, {encoding}, (error, data) => {
				if(error) return reject(error);
				return resolve(data.toString());
			});
		}
	});
}


/**
 * Normalise path separators.
 *
 * Well-formed URIs (those prefixed by `protocol://`)
 * are returned unmodified unless `clobber` is truthy.
 *
 * @example "C:\User\foo\..\bar" -> "C:/User/bar"
 * @param {String} input
 * @param {Boolean} [clobber=false]
 * @return {String}
 */
function normalisePath(input, clobber = false){
	if(!clobber && /^\w*:\/\//.test(input))
		return input;
	input = resolve(input || "");
	return "win32" === process.platform
		? input.replace(/\\/g, "/")
		: input;
}


/**
 * Asynchronously read the entirety of standard input.
 *
 * @param {String} [encoding="utf8"]
 * @return {Promise}
 */
function readStdin(encoding = "utf8"){
	return new Promise(resolve => {
		let input = "";
		process.stdin.setEncoding(encoding);
		process.stdin.on("readable", () => {
			const chunk = process.stdin.read();
			null !== chunk ? input += chunk : resolve(input);
		})
	});
}


/**
 * Synchronously read a number of bytes from a file.
 *
 * Previously named "sampleFile", renamed to eliminate ambiguity.
 * 
 * @param {String} path   - Path to file
 * @param {Number} length - Maximum number of bytes to read
 * @param {Number} offset - Offset to start reading from
 * @return {Array} An array of two values: the loaded data-string, and a
 * boolean indicating if the file was small enough to be fully loaded.
 */
function sipFile(path, length, offset = 0){
	if(!path || length < 1)
		return [null, false];
	
	let data = Buffer.alloc(length);
	const fd = fs.openSync(path, "r");
	const bytesRead = fs.readSync(fd, data, 0, length, offset);
	
	let isComplete = false;
	
	data = data.toString();
	if(bytesRead < data.length){
		isComplete = true;
		data = data.substring(0, bytesRead);
	}
	
	return [data, isComplete];
}


/**
 * Use a plain object to generate an [fs.Stats instance]{@link https://nodejs.org/api/all.html#fs_class_fs_stats}.
 *
 * Actual {@link fs.Stats} instances are returned unmodified.
 *
 * @see {@link https://nodejs.org/api/all.html#fs_class_fs_stats}
 * @param {Object} input
 * @return {fs.Stats}
 */
function statify(input){
	if(!input) return null;
	
	if("function" === typeof input.isSymbolicLink)
		return input;
	
	const output = Object.create(fs.Stats.prototype);
	for(const key in input){
		const value = input[key];
		
		switch(key){
			case "atime":
			case "ctime":
			case "mtime":
			case "birthtime":
				output[key] = !(value instanceof Date)
					? new Date(value)
					: value;
				break;
			default:
				output[key] = value;
		}
	}
	
	return output;
}


/**
 * Replace any occurrences of `$HOME` with a tilde.
 *
 * @example tildify("/Users/johngardner/Labs/Utils") == "~/Labs/Utils"
 * @param {String} input
 * @return {String}
 */
function tildify(input){
	if("win32" === process.platform)
		return input;
	const home = process.env.HOME + "/";
	return (0 === input.indexOf(home))
		? input.substr(home.length).replace(/^\/?/, "~/")
		: input;
}


/**
 * Return the subproperty located on an object at the designated path.
 *
 * @example
 * resolveProperty({foo: ["qux"]},  "foo[0]")    == "qux"
 * resolveProperty({foo: [0, [1]]}, "foo[1][9]") == undefined
 * 
 * @param {Object} object
 *    Subject to search the property values of.
 *
 * @param {String} path
 *    A string describing an accessor chain pointing to the desired property.
 *
 * @param {Boolean} [usePrevious=false]
 *    Instead of returning `undefined` for missing/invalid properties,
 *    return the last valid value that was accessed.
 * @example resolveProperty({foo: [0, [1]]}, "foo[1][9]", true) == 1
 
 * @return {*}
 *    Value of the referenced property, or `undefined` if the path
 *    pointed to an invalid or missing property.
 */
function resolveProperty(object, path, usePrevious = false){
	const segments = path.replace(/\[(['"])?([^\]]+)\1\]/g, ".$2").split(/\./);
	const {length} = segments;
	let prevObject = object;
	for(let i = 0; i < length; ++i){
		const name = segments[i];
		if(undefined === prevObject || !(name in prevObject))
			return usePrevious ? prevObject : undefined;
		prevObject = prevObject[name];
		if(i >= length - 1) return prevObject;
	}
	return undefined;
}


/**
 * Recursively alphabetise enumerable properties of an object.
 *
 * @param {Object}  input - Object being alphabetised; not modified by function.
 * @param {Boolean} [strictCase=false] - Order case-sensitively (capitals first).
 * @return {Object} Copy of input with all enumerable properties alphabetised.
 */
function alphabetiseProperties(input, strictCase = false){
	let stringTag = Object.prototype.toString.call(input);
	
	// Regular JavaScript object: enumerate properties
	if("[object Object]" === stringTag){
		let keys = Object.keys(input);
		
		keys = strictCase ? keys.sort() : keys.sort((a, b) => {
			let A = a.toLowerCase();
			let B = b.toLowerCase();
			if(A < B) return -1;
			if(A > B) return 1;
			return 0;
		});
		
		let result = {};
		for(let i of keys)
			result[i] = alphabetiseProperties(input[i]);
		return result;
	}
	
	// Array: ensure properties are sorted
	else if("[object Array]" === stringTag)
		return Array.prototype.map.call(input, e => alphabetiseProperties(e));
	
	// Neither: return untouched
	return input;
}


/**
 * Retrieve a descriptor for each property available on an object.
 *
 * Both inherited and non-enumerable properties are included.
 * The usual rules of prototypal inheritance apply; redefined
 * properties replace their inherited counterparts.
 *
 * @param {Object} subject
 * @return {Map} A list of property descriptors keyed by name.
 * @example getProperties(foo) == Map{"keys" => descriptors}
 */
function getProperties(subject){
	let object = subject;
	const refs = new WeakSet();
	const ancestry = [subject];
	while((object = Object.getPrototypeOf(object)) && !refs.has(object))
		ancestry.push(object);
	
	const result = new Map();
	for(const obj of ancestry.reverse()){
		const names = Object.getOwnPropertyNames(obj);
		for(const name of names){
			const desc = Object.getOwnPropertyDescriptor(obj, name);
			result.set(name, desc);
		}
	}
	
	return result;
}


/**
 * "Flatten" a (possibly nested) list of strings into a single-level array.
 *
 * Strings are split by whitespace as separate elements of the final array.
 *
 * @param {Array|String} input
 * @return {String[]} An array of strings
 */
function collectStrings(input, refs = null){
	refs = refs || new WeakSet();
	input = "string" === typeof input
		? [input]
		: refs.add(input) && Array.from(input);
	
	const output = [];
	for(const value of input){
		if(!value) continue;
		switch(typeof value){
			case "string":
				output.push(...value.split(/\s+/));
				break;
			case "object":
				if(refs.has(value)) continue;
				refs.add(value);
				output.push(...collectStrings(value, refs));
		}
	}
	return output;
}


/**
 * Filter an object's properties using a pattern.
 *
 * @example keyGrep(require.cache, /rimraf/);
 * @param {Object} subject
 * @param {RegExp|String} pattern
 * @return {Object}
 */
function keyGrep(subject, pattern){
	pattern = "string" === typeof pattern
		? new RegExp(pattern)
		: pattern;
	
	const output = {};
	for(const key of Object.keys(subject).filter(k => pattern.test(k)))
		output[key] = subject[key];
	return output;
}


/**
 * Return true if a variable is a {@link Number} or number-like {@link String}.
 * 
 * String-checking is intentionally restricted to "basic" numeric forms only.
 * Advanced notation like hexadecimal, exponential or binary literals are ignored:
 * strings like "0b10100100", "0xE4" and "3.1536e+10" will each return `false`.
 * 
 * @param {Mixed} i - Value to inspect
 * @return {Boolean}
 */
function isNumeric(i){
	return "" !== i && +i == i && (String(i) === String(+i) || !/[^\d\.]+/.test(i));
}


/**
 * Return true if the given value is a {@link RegExp|regular expression}.
 *
 * @param {*} input
 * @return {Boolean}
 */
function isRegExp(input){
	return "[object RegExp]" === Object.prototype.toString.call(input);
}


/**
 * Return true if the given value is a {@link String}.
 *
 * @param {*} input
 * @return {Boolean}
 */
function isString(input){
	return "[object String]" === Object.prototype.toString.call(input);
}


/**
 * Parse a list of keywords into an object of boolean `true` values.
 *
 * @example parseKeywords("top left") -> {top: true, left: true}
 * @param {String|String[]} keywords - A space-delimited string or an array of strings
 * @return {Object.<String, Boolean>}
 */
function parseKeywords(keywords){
	if(!Array.isArray(keywords)){
		if(!keywords) return null;
		keywords = [keywords];
	}
	
	const output = {};
	for(const k of keywords)
		k.split(/\s+/g).filter(i => i).forEach(k => output[k] = true);
	return output;
}


/**
 * Perform basic animation of an object's property.
 *
 * @uses {@link deCasteljau}
 * @example
 * // Animated scrolling
 * tween(document.documentElement, "scrollTop", scrollY + 600);
 * tween(document.documentElement, "scrollTop", scrollY - 100, {duration: 6000});
 * 
 * // Faux progress meter
 * tween(element, "textContent", 100, {
 *     duration: 8000,
 *     curve:    tween.LINEAR,
 *     filter:   num => `Loading: ${num}%`
 * });
 *
 * @param   {Object} subject - Target object whose property is being animated
 * @param   {String} propertyName - Animated property's name
 * @param   {Number} endValue - Animated property's value after tween has completed
 * @param   {Object} [options={}] - Optional tweening settings
 * @param  {Point[]} [options.curve=tween.EASE] - Easing function expressed as a Bézier curve
 * @param {Function} [options.callback=null] - Callback fired after each interpolated frame
 * @param {Function} [options.filter=null] - Override value before assigning to property
 * @param   {Number} [options.duration=300] - Animation length in milliseconds
 * @param   {Number} [options.fps=60] - Animation frame rate
 * @return {Promise} Resolves once playback finishes or is cancelled
 * by calling the `stop` method defined by the returned Promise object.
 */
function tween(subject, propertyName, endValue, options = {}){
	let stopped = false;
	return Object.assign(new Promise(resolve => {
		const {
			curve    = tween.EASE,
			callback = null,
			filter   = null,
			duration = 300,
			fps      = 60,
		} = options;
		const delay = 1 / fps * 1000;
		const from  = +subject[propertyName] || 0;
		const to    = endValue;
		const step  = (progress, iterations) => {
			if(stopped)
				return resolve();
			const midpoint = deCasteljau(curve, progress)[0][1];
			if(midpoint >= 1){
				const value = (null !== filter) ? filter(to, 1) : to;
				subject[propertyName] = value;
				if(null !== callback)
					callback(value, 1);
				return resolve();
			}
			if(progress){
				let value = from + ((to - from) * midpoint);
				if(null !== filter)
					value = filter(value, progress);
				subject[propertyName] = value;
				if(null !== callback)
					callback(value, progress);
			}
			setTimeout(() => {
				step(delay * iterations / duration, ++iterations);
			}, delay);
		};
		step(0, 0);
	}), {stop: () => stopped = true});
}

Object.assign(tween, {
	LINEAR:      [[0, 0], [1, 1]],
	EASE:        [[0, 0], [.25, .1], [.25, 1], [1, 1]],
	EASE_IN:     [[0, 0], [.42, 0],  [1, 1],   [1, 1]],
	EASE_IN_OUT: [[0, 0], [.42, 0],  [.58, 1], [1, 1]],
	EASE_OUT:    [[0, 0], [0, 0],    [.58, 1], [1, 1]],
});


/**
 * Synthesise case-insensitivity for a regexp string.
 *
 * JavaScript doesn't support scoped modifiers like (?i),
 * so this function attempts to approximate the closest thing.
 *
 * @param {String} input - Case-insensitive text
 * @param {Boolean} fuzz - Apply {@link fuzzyRegExp} to input
 * @uses {@link fuzzyRegExp}
 * @return {String}
 */
function caseKludge(input, fuzz = false){
	let output = input.split("").map((s, index, array) => {
		if(/[A-Z]/.test(s)){
			const output = "[" + s + s.toLowerCase() + "]";
			const prev   = array[index - 1];
			if(fuzz && prev && /[a-z]/.test(prev))
				return "[\\W_\\S]*" + output;
			return output;
		}
		if(/[a-z]/.test(s))     return "[" + s.toUpperCase() + s + "]";
		if(!fuzz)               return s.replace(/([/\\^$*+?{}\[\]().|])/g, "\\$1");
		if("0" === s)           return "[0Oo]";
		if(/[\W_ \t]?/.test(s)) return "[\\W_ \\t]?";
		return s;
	}).join("");
	
	if(fuzz)
		output = output.replace(/\[Oo\]/g, "[0Oo]");
	return output.replace(/(\[\w{2,3}\])(\1+)/g, (match, first, rest) => {
		return first + "{" + ((rest.length / first.length) + 1) + "}"
	});
}


/**
 * Turn capturing groups in an expression into non-capturing groups.
 *
 * @example forceNonCapturing(/([A-Z]+)/) == /(?:[A-Z]+)/
 * @param {RegExp} pattern
 * @return {RegExp}
 */
function forceNonCapturing(pattern){
	const source = pattern.source
		.split(/\((?!\?[=<!])/)
		.map((segment, index, array) => {
			if(!index) return segment;
			return !/^(?:[^\\]|\\.)*\\$/.test(array[index - 1])
				? segment.replace(/^(?:\?:)?/, "(?:")
				: segment.replace(/^/, "(");
		})
		.join("");
	return new RegExp(source, pattern.flags);
}


/**
 * Generate a regex to match a string, bypassing intermediate punctuation.
 *
 * E.g., "CoffeeScript" matches "coffee-script", "cOfFeE sCRiPT" or even
 * "C0FFEE.SCRIPT". Useful when words have multiple possible spellings.
 *
 * @param {String} input - A string, such as "reStructuredText" or "dBASE"
 * @param {Function} format - Desired output format (String or RegExp)
 * @return {String|RegExp}
 */
function fuzzyRegExp(input, format = RegExp){
	if("[object String]" !== Object.prototype.toString.call(input))
		return input;
	
	const output = input
		.replace(/([A-Z])([A-Z]+)/g, (a, b, c) => b + c.toLowerCase())
		.split(/\B(?=[A-Z])|[-\s]/g)
		.map(i => i.replace(/([/\\^$*+?{}\[\]().|])/g, "\\$1?"))
		.join("[\\W_ \\t]?")
		.replace(/[0Oo]/g, "[0o]");
	
	// Author's requested the regex source, return a string
	if(String === format)
		return output;
	
	// Otherwise, crank the fuzz
	return new RegExp(output, "i");
}


/**
 * Generate a RegEx from its string-based representation.
 *
 * Useful for "deserialising" a regex from JSON. Optional flags can be given
 * to override trailing modifiers found in the source, if any.
 *
 * @example "/\\S+/i"       -> /\S+/i
 * @example "\\d+\\.\\d+$"  -> /\d+\.\d+$/
 * @param  {String} src
 * @param  {String} flags
 * @return {RegExp} regex
 */
function regexFromString(src, flags){
	src = (src || "").toString();
	if(!src) return null;
	
	const matchEnd = src.match(/\/([gimuy]*)$/);
	
	/** Input is a "complete" regular expression */
	if(matchEnd && /^\//.test(src))
		return new RegExp(
			src.replace(/^\/|\/([gimuy]*)$/gi, ""),
			flags != null ? flags : matchEnd[1]
		);
	
	return new RegExp(src, flags);
}


/**
 * Escape special regex characters within a string.
 *
 * @example "file.js" -> "file\\.js"
 * @param {String} input
 * @return {String}
 */
function escapeRegExp(input){
	return input.replace(/([/\\^$*+?{}\[\]().|])/g, "\\$1");
}


/**
 * Align a string by padding it with leading/trailing whitespace.
 *
 * @return {String}
 * @example
 * alignText("Text",   10)            == "   Text   ";
 * alignText(" Text ", 14, 0.5, "-")  == "---- Text ----";
 * alignText("Text",   14, 0.75, "=") == "========Text===";
 *
 * @param {String} input
 *    String to align with padding.
 *
 * @param {Number} width
 *    Character width of containing textarea.
 *
 * @param {Number} [axis=0.5]
 *    Alignment axis, expressed as a multiplier between `0.0` (left-aligned)
 *    and `1.0` (right-aligned). Default is `0.5` (centred output).
 *
 * @param {String} [char=" "]
 *    Character to use as padding. Defaults to space (U+0020).
 */
function alignText(input, width, axis = 0.5, char = " "){
	const emptySpace = width - input.length;
	
	// Bail early if there's nothing to do here
	if(emptySpace < 1) return input;
	
	const left  = emptySpace * axis;
	const right = emptySpace - left;
	return char.repeat(Math.round(left)) + input + char.repeat(Math.round(right));
}


/**
 * Convert a camelCased string to its kebab-cased equivalent.
 *
 * @example camelToKebabCase("fooBar") == "foo-bar"
 * @param {String} input
 * @return {String}
 */
function camelToKebabCase(input){
	return /^([a-z]+[A-Z])+[a-z]+$/.test(input)
		? input.replace(/([a-z]+)([A-Z])/g, (_,a,B) => `${a}-${B}`).toLowerCase()
		: input;
}


/**
 * Locate the root directory shared by multiple paths.
 *
 * @param {String[]} paths - A list of filesystem paths
 * @return {String} root
 */
function findBasePath(paths){
	const POSIX = -1 !== paths[0].indexOf("/");
	let matched = [];
	
	// Spare ourselves the trouble if there's only one path.
	if(1 === paths.length){
		matched = (paths[0].replace(/[\\/]+$/, "")).split(/[\\/]/g);
		matched.pop();
	}
	else{
		const rows   = paths.map(d => d.split(/[\\/]/g));
		const width  = Math.max(...rows.map(d => d.length));
		const height = rows.length;
		let x, y;
		X: for(x = 0; x < width; ++x){
			const str = rows[0][x];
			for(let y = 1; y < height; ++y)
				if(str !== rows[y][x]) break X;
			matched.push(str);
		}
	}
	
	return matched.join(POSIX ? "/" : "\\");
}


/**
 * Format a number of bytes for human-readable output.
 *
 * @example formatBytes(3524959) == "3.36 MB"
 * @param {Number} bytes
 * @return {String} A reader-friendly representation of filesize.
 */
function formatBytes(bytes){
	let unit;
	for(unit of new Array("B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"))
		if(bytes >= 1024) bytes /= 1024; else break;
	return `${Math.round(bytes * 100) / 100} ${unit}`;
}


/**
 * Return a character not contained in a string.
 *
 * @example getUnusedChar("\x00\x02") == "\x01"
 * @param {String} input
 * @return {String}
 */
function getUnusedChar(input){
	let char = "\x00";
	let code = 0;
	while(-1 !== input.indexOf(char))
		char = String.fromCodePoint(++code);
	return char;
}


/**
 * Inclusive string-splitting method.
 *
 * Identical to {@link String.prototype.split}, except
 * matched delimiters are included with the results.
 *
 * @example
 * ("A-B").split(/-/) == ["A", "B"];
 * isplit("A-B", /-/) == ["A", "-", "B"];
 * 
 * @param {String} input
 * @param {RegExp} pattern
 * @return {String[]}
 */
function isplit(input, pattern){
	const output = [];
	
	// String-type pattern: convert to RegExp
	if("string" === typeof pattern)
		pattern = new RegExp(pattern, "g");
	
	// Non-global regexp: avoid infinite recursion
	else if(!pattern.global)
		pattern = new RegExp(pattern.source, pattern.flags + "g");
	
	let start = 0, match;
	while(match = pattern.exec(input)){
		const [substring] = match;
		const {lastIndex} = pattern;
		const delimiter = input.substring(start, lastIndex - substring.length);
		output.push(delimiter, substring);
		start = lastIndex;
	}
	
	const {length} = input;
	if(start < length)
		output.push(input.substring(start, length));
	
	return output;
}


/**
 * Check if a string is a valid 16-digit credit card number.
 *
 * Non-alphanumeric separators like hyphens or spaces are ignored when determining validity.
 *
 * @example isValidCCNumber("1234-5678-N0PE-8432") == false
 * @param {String} input
 * @return {Boolean}
 */
function isValidCCNumber(input){
	return /^([^\dA-Za-z]*\d[^\dA-Za-z]*){16}$/.test(input);
}


/**
 * Convert a kebab-cased-string to a camelCasedString.
 *
 * @example kebabToCamelCase("foo-bar") == "fooBar"
 * @see {@link camelToKebabCase}
 * @param {String} input
 * @return {String}
 */
function kebabToCamelCase(input){
	return input.toLowerCase().replace(/([a-z])-+([a-z])/g, (_, a, b) => a + b.toUpperCase());
}


/**
 * Return the English ordinal suffix for a number (-st, -nd, -rd, -th).
 *
 * @example ordinalSuffix(22) == "nd"
 * @param {Number} n - A number (preferably an integer) to return the suffix for.
 * @return {String}
 */
function ordinalSuffix(n){
	return [,"st", "nd", "rd"][((n %= 100) > 10 && n < 20) ? 0 : (n % 10)] || "th";
}



/**
 * Split a URL into separate components.
 *
 * @return {ParsedURL}
 * @param {String} path - Directory path or URI (either absolute or relative)
 *
 * @example
 * parseURL("https://github.com/page.php?foo=bar&qux#top") == {
 *    protocol: "https://",
 *    path: "github.com/",
 *    filename: "login.php",
 *    query: "?foo=bar&qux",
 *    fragment: "#top",
 * };
 *
 * // Works with system filepaths too:
 * parseURL("/usr/share/man/whatis") == {
 *    protocol: "",
 *    path: "/usr/share/man/",
 *    filename: "whatis",
 *    query: "",
 *    fragment: ""
 * };
 */
function parseURL(path){
	const pattern = /^([^\/#\?]*:?\/\/)?(\/?(?:[^\/#\?]+\/)*)?([^\/#\?]+)?(?:\/(?=$))?(\?[^#]*)?(#.*)?$/;
	const matches = path.match(pattern) || [];
	return {
		protocol: matches[1] || "",
		path:     matches[2] || "",
		filename: matches[3] || "",
		query:    matches[4] || "",
		fragment: matches[5] || "",
	};
}

/**
 * An object enumerated with substrings matched by {@link parseURL}.
 * @typedef {Object.<String, String>} ParsedURL
 * @property {String} protocol - Protocol with :// appended
 * @property {String}     path - Directory path (including hostname/domain)
 * @property {String} filename - Filename/basename
 * @property {String}    query - ?query=string
 * @property {String} fragment - #Hash
 */


/**
 * Generate an ID-safe slug from a name.
 *
 * @example slug("Here's an ID string.") == "heres-an-id-string"
 * @param {String} name
 * @return {String}
 */
function slug(name){
	return (name || "").toString()
		.toLowerCase()
		.replace(/(\w)'(re)(?=\s|$)/g, "$1-are")
		.replace(/(\w)'s(?=\s|$)/g, "$1s")
		.replace(/[^\w$]/g, "-")
		.replace(/-+/g, "-")
		.replace(/^-+|-+$/g, "")
}


/**
 * Capitalise a string using basic English title-case rules.
 *
 * @todo Write thorough specs for this; still slightly flaky.
 * @example titleCase("Lord Of The Rings") == "Lord of the Rings"
 * @param {String} input
 * @return {String}
 */
function titleCase(input){
	const _ = true;
	const lcWords = {
		a: _, an:_, and:_, but:_, for:_, in:_, nor:_,
		of:_, on:_,  or:_, the:_,  to:_, to:_, with:_,
	};
	const [firstChar, ...remainder] = input
		.toLowerCase()
		.replace(/\b(\w)(\w*)/gi, (word, firstLetter, remainder, index, input) => {
			
			// Single letter
			if(undefined === remainder) return firstLetter.toUpperCase();
		
			// Use lowercase for articles, conjunctions, prepositions, etc
			if(true === lcWords[word]) return word;
			
			// Beware of contractions
			if("'" === input[index - 1] && /\w'$/.test(input.substring(index, 0)))
				return word;
		
			return firstLetter.toUpperCase() + remainder;
		})
		.replace(/(^|\s)i(?!\w)/g, "$1I");  // Capitalise pronoun form of "I"
	return firstChar.toUpperCase() + remainder.join("");
}


/**
 * Generate a tree of values based on line indentation.
 *
 * Parent/child relationships are described by leading indentation.
 * Nodes are serialised as plain objects, each enumerated with 1-2 properties:
 *
 *    name:      Line's textual content, sans whitespace
 *    children:  An array of similarly-structured child nodes
 *
 * @param {String} input - Block of tab/newline-delimited data
 * @return {Object[]} A tree of object-nodes.
 */
function tokeniseOutline(input){
	input = input.replace(/^([ \t]*\n)*|(\n\s*)*$/g, "");
	const output = [];
	const indent = input.match(/^[\t ]+(?=\S)/);
	if(indent){
		const stripIndent = new RegExp("^" + indent[0], "gm");
		input = input.replace(stripIndent, "");
	}
	let prev, currentLevel = 0;
	for(let l of input.split(/\n+/g)){
		let level = l.match(/^\t*/)[0].length;
		let name = l.replace(/^\t+/, "");
		let node = {level, name, toJSON: function(){
			const o = Object.assign({}, this);
			delete o.parent;
			return o;
		}};
		// Indent
		if(level > currentLevel){
			node.parent = prev;
			(prev.children = prev.children || []).push(node);
			currentLevel = level;
		}
		// Outdent
		else if(level < currentLevel)
			while(prev){
				if(prev.level <= level){
					currentLevel = prev.level;
					prev.parent
						? prev.parent.children.push(node)
						: output.push(node);
					node.parent = prev.parent;
					break;
				}
				prev = prev.parent;
			}
		// New sibling
		else{
			if(level){
				prev = prev.parent;
				prev.children.push(node)
				node.parent = prev;
			}
			else output.push(node)
		}
		prev = node;
	}
	return output;
}


/**
 * Count the number of words in a string.
 *
 * @example wordCount("Bunch of odd-looking functions") == 4
 * @param {String} input
 * @param {Boolean} [ignoreHyphens=false] - Treat "foo-bar" as 2 words, not 1
 * @return {Number}
 */
function wordCount(input, ignoreHyphens = false){
	const nonWordChars = ignoreHyphens ? /\W+/g : /[^-\w_]+/g;
	const words = input
		.replace(nonWordChars, " ")
		.replace(/^\s+|\s+$/g, "")
		.split(/\s+/);
	return words[0] ? words.length : 0;
}


/**
 * Wrap a string to a specified line-length.
 *
 * Words are pushed onto the following line, unless they exceed the line's total length limit.
 *
 * @param {String} input
 *    Block of text to wrap.
 * 
 * @param {Number} [length=80]
 *    Maximum number of characters permitted on each line.
 * 
 * @return {String[]} An array of wrapped lines, preserving any newlines in the original text.
 */
function wordWrap(input, length = 80){
	const output = [];
	const l = input.length;
	
	for(let i = 0, s; i < l; i += length){
		let segment = input.substring(i, i + length);
		
		// Segment contains at least one newline.
		const nl = segment.lastIndexOf("\n");
		if(-1 !== nl){
			output.push(segment.substring(0, nl + 1));
			segment = segment.substring(nl + 1);
		}
		
		// We're attempting to cut on a non-whitespace character. Do something.
		if(/\S/.test(input[(i + length) - 1]) && (s = segment.match(/\s(?=\S+$)/))){
			output.push(segment.substr(0, i + length > l ? l : (s.index + 1)));
			i = (i - (s.input.length - s.index)) + 1;
		}
		else output.push(segment);
	}
	return output;
}


/**
 * Add leading zeroes if necessary.
 *
 * @example zeroise(5, 2) == "05"
 * @param {Number} value - Number being formatted.
 * @param {Number} min - Minimum required length.
 * @return {String}
 */
function zeroise(value, min){
	value = value.toString();
	const {length} = value;
	if(length < min)
		value = "0".repeat(min - length) + value;
	return value;
}

const {CompositeDisposable, Disposable} = ("object" === typeof global.atom) ? require("atom") : {};


/**
 * Map-based equivalent of a {@link CompositeDisposable}.
 *
 * @class
 */
class MappedDisposable {
	
	/**
	 * Create a new instance, optionally with a list of keys and disposables.
	 *
	 * @example new MappedDisposable([ [key1, disp1], [key2, disp2] ]);
	 * @param {*} [iterable]
	 * @constructor
	 */
	constructor(iterable = null){
		this.disposables = new Map();
		
		if(null !== iterable)
			for(let [key, value] of iterable){
				if(!(value instanceof CompositeDisposable))
					value = new CompositeDisposable(value);
				this.disposables.set(key, value);
			}
	}
	

	/**
	 * Delete keys and dispose of their values.
	 *
	 * If passed no arguments, the method disposes of everything, rendering the
	 * MappedDisposable instance completely inert. Future method calls do nothing.
	 *
	 * @param {...} [keys] - Keys to dispose
	 */
	dispose(...keys){
		if(this.disposed)
			return;
		
		// If objects were provided, target the disposables specifically
		if(keys.length){
			for(const key of keys){
				const disposable = this.disposables.get(key);
				if(key && "function" === typeof key.dispose)
					key.dispose();
				if(disposable){
					disposable.dispose();
					this.disposables.delete(key);
				}
			}
		}
		
		// Otherwise, dispose the MappedDisposable itself
		else{
			this.disposed = true;
			this.disposables.forEach((value, key) => {
				value.dispose();
				if(key && "function" === typeof key.dispose)
					key.dispose();
			});
			this.disposables.clear();
			this.disposables = null;
		}
	}
	
	
	/**
	 * Key one or more disposables to an object.
	 *
	 * @param {*} key
	 * @param {...} disposables
	 */
	add(key, ...disposables){
		if(this.disposed)
			return;
		
		const keyDisposables = this.disposables.get(key);
		keyDisposables
			? keyDisposables.add(...disposables)
			: this.disposables.set(key, new CompositeDisposable(...disposables));
	}


	/**
	 * Remove a disposable from an object's disposables list.
	 *
	 * If no disposables are passed, the object itself is removed from the
	 * MappedDisposable. Any disposables keyed to it are not disposed of.
	 *
	 * @param {*} key
	 * @param {...} [disposables]
	 */
	remove(key, ...disposables){
		if(this.disposed)
			return;
		
		const disposable = this.disposables.get(key);
		if(disposable){
			
			// Remove specific disposables if any were provided
			if(disposables.length){
				for(const unwantedDisposable of disposables)
					disposable.remove(unwantedDisposable);
			}
			
			// Otherwise, remove the keyed object itself
			else this.disposables.delete(key);
		}
	}
	
	
	/**
	 * Alias of {@link MappedDisposable#remove}, included for parity with {@link Map} objects.
	 *
	 * @param {*} key
	 * @param {...} [disposables]
	 * @see {@link MappedDisposable#remove}
	 */
	delete(key, ...disposables){
		this.remove(key, ...disposables);
	}
	
	
	/**
	 * Clear the contents of the MappedDisposable.
	 *
	 * Disposables keyed to objects are not disposed of.
	 */
	clear(){
		if(this.disposed)
			return;
		this.disposables.clear();
	}


	/**
	 * Number of entries (key/disposable pairs) stored in the instance.
	 *
	 * @readonly
	 * @return {Number}
	 */
	get size(){
		return this.disposed
			? 0
			: this.disposables.size;
	}	
	
	
	/**
	 * Determine if an entry with the given key exists in the MappedDisposable.
	 *
	 * @param {*} key
	 * @return {Boolean}
	 */
	has(key){
		return this.disposed
			? false
			: this.disposables.has(key);
	}
	
	
	/**
	 * Retrieve the disposables list keyed to an object.
	 *
	 * If the MappedDisposable has been disposed, the method returns `undefined`.
	 *
	 * @param {*} key
	 * @return {CompositeDisposable}
	 */
	get(key){
		return this.disposed
			? undefined
			: this.disposables.get(key);
	}
	
	
	/**
	 * Replace the disposable that's keyed to an object.
	 *
	 * A TypeError is thrown if the object lacks a `dispose` method.
	 *
	 * @param {*} key
	 * @param {Disposable} value
	 */
	set(key, value){
		if(this.disposed)
			return;
		
		if(!Disposable.isDisposable(value))
			throw new TypeError("Value must have a .dispose() method");
		
		this.disposables.set(key, value);
	}
}


MappedDisposable.prototype.disposed = false;

const instancePatterns = new WeakMap();


/**
 * RegExp-aware version of an [ES6 Map]{@link https://mdn.io/Map}.
 *
 * Regular expressions are treated as primitives, not objects: two
 * fundamentally identical expressions will always be keyed to the
 * same value.
 *
 * @class
 */
class PatternMap extends Map {
	
	/**
	 * Create a new PatternMap, optionally with initial keys and values.
	 *
	 * @param {*} [iterable] - An iterable in the format expected by Map constructors.
	 * @throws {TypeError} Keys must be strings or {@link RegExp} instances.
	 * @constructor
	 */
	constructor(iterable = null){
		super();
		instancePatterns.set(this, new Map());
		
		if(null !== iterable)
			for(const entry of iterable)
				this.set(...entry);
	}
	
	
	/**
	 * Check if an entry exists that's keyed to the designated pattern.
	 *
	 * @param {String|RegExp} key
	 * @return {Boolean}
	 */
	has(key){
		const patterns = instancePatterns.get(this);
		const string = key.toString();
		return patterns.has(string);
	}
	
	
	/**
	 * Retrieve the value keyed to a pattern.
	 *
	 * @param {String|RegExp}
	 * @return {*}
	 */
	get(key){
		if(!key) return undefined;
		const patterns = instancePatterns.get(this);
		const string = key.toString();
		const regexp = patterns.get(string);
		return super.get(regexp);
	}
	
	
	/**
	 * Add or modify the value keyed to a specified pattern.
	 *
	 * @param  {String|RegExp} key
	 * @param  {*} value
	 * @throws {TypeError} Key must be a string or {@link RegExp}.
	 * @return {PatternMap} Reference to the calling `PatternMap`.
	 */
	set(key, value){
		let string = key.toString();
		let regexp = key;
		
		if(!(key instanceof RegExp))
			throw new TypeError("PatternMap keys must be regular expressions");
		
		const patterns = instancePatterns.get(this);
		
		patterns.has(string)
			? regexp = patterns.get(string)
			: patterns.set(string, regexp);
		
		return super.set(regexp, value);
	}
	
	
	/**
	 * Delete the value that's keyed to a pattern, if any.
	 *
	 * @param {String|RegExp} key
	 * @return {Boolean} Whether the key existed and was deleted.
	 */
	delete(key){
		const patterns = instancePatterns.get(this);
		const string = key.toString();
		const regexp = patterns.get(string);
		
		if(regexp){
			patterns.delete(string);
			return super.delete(regexp);
		}
		
		else return false;
	}
	
	
	/**
	 * Remove all patterns and values held in the instance.
	 */
	clear(){
		const patterns = instancePatterns.get(this);
		patterns.clear();
		super.clear();
	}
	
	
	/**
	 * Return the PatternMap's default textual description.
	 *
	 * @return {String}
	 */
	get [Symbol.toStringTag](){
		return "PatternMap";
	}
}



/**
 * RegExp-aware version of an [ES6 Set]{@link https://mdn.io/Set}.
 *
 * Regular expressions are treated as primitives, not objects: two
 * fundamentally identical expressions will always be keyed to the
 * same value.
 *
 * @class
 */
class PatternSet extends Set {

	/**
	 * Instantiate a new PatternSet, optionally with initial patterns.
	 *
	 * @param {*} [iterable] - An iterable of patterns to add
	 * @constructor
	 */
	constructor(iterable = null){
		super();
		instancePatterns.set(this, new Map());
		
		if(null === iterable)
			return;
		
		for(const entry of iterable)
			if(null != entry)
				this.add(entry);
	}
	
	
	/**
	 * Add a new pattern to the PatternSet.
	 *
	 * @param {RegExp} pattern
	 * @throws {TypeError} Values must be {@link RegExp} objects.
	 * @return {PatternSet} The calling instance
	 */
	add(pattern){
		if(!(pattern instanceof RegExp))
			throw new TypeError("Values added to a PatternSet must be regular expressions");
		
		const patterns = instancePatterns.get(this);
		const string   = pattern.toString();
		if(!patterns.has(string)){
			patterns.set(string, pattern);
			return super.add(pattern);
		}
		return this;
	}
	
	
	/**
	 * Remove a pattern from the PatternSet.
	 *
	 * @param {RegExp} pattern
	 * @return {Boolean} Whether the specified pattern was found and deleted.
	 */
	delete(pattern){
		const patterns = instancePatterns.get(this);
		const string = pattern.toString();
		const regexp = patterns.get(string);
		if(regexp){
			patterns.delete(string);
			return super.delete(regexp);
		}
		return false;
	}
	
	
	/**
	 * Empty the contents of the PatternSet.
	 */
	clear(){
		const patterns = instancePatterns.get(this);
		patterns.clear();
		super.clear();
	}
	
	
	/**
	 * Check if a pattern exists in the PatternSet.
	 *
	 * @param {String|RegExp} pattern
	 * @return {Boolean}
	 */
	has(pattern){
		const patterns = instancePatterns.get(this);
		const string = pattern.toString();
		return patterns.has(string);
	}
	
	
	/**
	 * Return the PatternSet's default textual description.
	 *
	 * @return {String}
	 */
	get [Symbol.toStringTag](){
		return "PatternSet";
	}
}

module.exports = {
	addTo,
	alignText,
	alphabetiseProperties,
	angleTo,
	base64Decode,
	base64Encode,
	bindMethods,
	buildDict,
	camelToKebabCase,
	caseKludge,
	chain,
	clamp,
	collectStrings,
	collectTextNodes,
	cookie,
	debounce,
	deCasteljau,
	deepest,
	degToRad,
	distance,
	drawHTML,
	drawPolygon,
	drawTextArea,
	escapeRegExp,
	extractTableData,
	findBasePath,
	forceNonCapturing,
	formatBytes,
	fuzzyRegExp,
	getCanvasFont,
	getProperties,
	getScrollbarWidth,
	getUnusedChar,
	getWebGLSupport,
	injectWordBreaks,
	isIE,
	isNumeric,
	isplit,
	isRegExp,
	isString,
	isValidCCNumber,
	kebabToCamelCase,
	keyGrep,
	load,
	MappedDisposable,
	nearest,
	nerf,
	New,
	normalisePath,
	ordinalSuffix,
	parseCSSDuration,
	parseHTMLFragment,
	parseKeywords,
	parseURL,
	PatternMap,
	PatternSet,
	punch,
	radToDeg,
	random,
	readStdin,
	regexFromString,
	resolveProperty,
	rgba,
	sipFile,
	slug,
	statify,
	supportsCSSProperty,
	supportsCSSSelector,
	supportsCSSUnit,
	tildify,
	titleCase,
	tokeniseOutline,
	tween,
	UTF8Decode,
	UTF8Encode,
	wait,
	wordCount,
	wordWrap,
	zeroise,
};

// Generate non-breaking fs functions
Object.assign(module.exports, {
	lstat:     nerf(fs.lstatSync),
	realpath:  nerf(fs.realpathSync),
});
